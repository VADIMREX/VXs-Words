<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>VX's Words</title>
  <script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/javascript">
    /**
     * @template TArgs extends any[]
     */
    class VXsEvent {
      constructor() {
        /** @type {((...args:TArgs)=>void)[]} */
        this.callbacks = [];
      }
      /** 
       * @param {(...args:TArgs)=>void} callback
       */
      subscribe(callback) {
        this.callbacks.push(callback)
      }
      /** 
       * @param {(...args:TArgs)=>void} callback
       */
      unsubscribe(callback) {
        let index = this.callbacks.findIndex(x => x === callback);
        if (undefined == index) return;
        this.callbacks.splice(index, 1);
      }
      /**
       * @param {TArgs} args
       */
      invoke(...args) {
        let errors = [];
        for (let k in this.callbacks) if (this.callbacks[k].apply(null, args)) try { this.callbacks[k](value) } catch (e) { errors.push(e); }
        if (0 != errors.length) throw ["errors on invoke of event", errors];
      }
    }

    /** 
     * Разбить текст на слова
     * @param {string} str 
     */
    function splitOnSpecialChars(str) {
      let set = new Set([
        "~", "`",
        "!", "@", "#", "$", "%", "^", "&", "*", "(", ")",
        "_", "+", "-", "=",
        "[", "]", "{", "}", "\\", "|",
        ";", "'", ":", "\"",
        ",", ".", "<", ">", "/", "?",
        " ", "\t", "\r", "\n"
      ]);
      let arr = Array.from(str);
      let res = [];
      let buff = [];
      for (let i = 0; i < arr.length; i++) {
        if (!set.has(arr[i])) {
          buff.push(arr[i]);
          continue;
        }
        if (0 == buff.length) continue;
        res.push(buff.join(""));
        buff = [];
      }
      if (buff.length > 0) res.push(buff.join(""));
      return res;
    }
    function b64EncodeUnicode(str) {
      // first we use encodeURIComponent to get percent-encoded UTF-8,
      // then we convert the percent encodings into raw bytes which
      // can be fed into btoa.
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
        function toSolidBytes(match, p1) {
          return String.fromCharCode('0x' + p1);
        }));
    }
    function b64DecodeUnicode(str) {
      // Going backwards: from bytestream, to percent-encoding, to original string.
      return decodeURIComponent(atob(str).split('').map(function (c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
    }
  </script>
  <script type="text/javascript">
    /**
     * сохранить файл 
     * @param {string} filename
     * @param {string} text
     */
    function saveFile(filename, text) {
      let oFile = document.createElement('a');
      oFile.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
      oFile.setAttribute('download', filename);
      if (document.createEvent) {
        let event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        oFile.dispatchEvent(event);
      }
      else {
        oFile.click();
      }
    }

    /**
     * открыть файл
     * @param {(this:Scope, content: string )=>void} callback
     * @param {Scope} scope
     * @template Scope
     */
    function openFile(callback, scope) {
      var iFile = document.createElement('input');
      iFile.type = 'file';
      iFile.onchange = e => {
        var reader = new FileReader();
        reader.readAsText(e.target.files[0], 'UTF-8');
        reader.onload = readerEvent => callback.call(scope || this, readerEvent.target.result);
      }
      if (document.createEvent) {
        let event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        iFile.dispatchEvent(event);
      }
      else {
        iFile.click();
      }
    }

    const CookieManager = new class {

      /**
       * @param {string} key
       * @return {string}
       */
      getRaw(key) {
        return document.cookie.replace(`(?:(?:^|.*;\\s*)${key}\\s*\\=\\s*([^;]*).*$)|^.*$`, "$1");
      }
      /**
       * @param {string} key
       * @param {T?} def
       * @return {T}
       * @template T
       */
      get(key, def) {
        if (arguments.length < 2) def = null;
        let s = this.getRaw(key);
        s = b64DecodeUnicode(s);
        return s ? JSON.parse(s) : def;
      }
      /**
       * @param {string} key
       * @param {string} value
       */
      setRaw(key, value) {
        document.cookie = `${key}=${value}`;
      }
      /**
       * @param {string} key
       * @param {any} value
       */
      set(key, value) {
        value = null == value ? "" : JSON.stringify(value);
        value = b64EncodeUnicode(value);
        this.setRaw(key, value);
      }
    }
    const WordsManager = new class {
      constructor() {

      }
      getWordKey(word) {
        let res = {};
        for (let i = 0; i < word.length; i++)
          if (!res[word[i]]) res[word[i]] = 1;
          else res[word[i]]++;
        return res;
      }
      checkTwoKeys(key1, key2) {
        for (let i in key1)
          if ((key2[i] || 0) < key1[i]) return false;
        return true;
      }

      /** найти самое часто встречающееся слово */
      getMostCommon() {
        /** @type {number} */
        this.mostCommon = 0;
        Object.entries(this.words).forEach(w => this.mostCommon = this.mostCommon > w[1] ? this.mostCommon : w[1]);
        return this.mostCommon;
      }
      /** найти наидлиннейшее слово */
      getLongest() {
        /** @type {number} */
        this.longest = 0;
        Object.entries(this.words).forEach(w => this.longest = this.longest > w[0].length ? this.longest : w[0].length);
        return this.longest;
      }
      /** 
       * Импорт текста
       * @param {string} text текст
       */
      importText(text) {
        this.words = {};
        let wordArr = splitOnSpecialChars(text);
        for (let i = 0; i < wordArr.length; i++) {
          let word = wordArr[i].toUpperCase()
          if (!this.words[word]) this.words[word] = 1;
          else this.words[word]++;
        }
        this.getMostCommon();
        this.getLongest();
      }
      /** 
       * Найти случайное слово
       * @param {number?} minLength минимальная длинна слова, по умолчанию поиск по всем словам
       * @return {string} 
       */
      getRndWord(minLength) {
        if (undefined == minLength) minLength = 0;
        let findedWords = Object.entries(this.words)
          .filter(x => x[0].length > minLength)
          .map(x => x[0]);
        return findedWords[Math.floor(Math.random() * findedWords.length)]
      }
      /**
       * Проверить редкость слова
       * @param {string} word слово
       * @return от 0 до 1 на сколько слово редкое:
       * - 1 самое редкое
       * - 0 самое обычное или не найденное
       */
      checkRarity(word) {
        let rarity = this.words[word];
        return rarity > 0 ? (this.mostCommon - rarity) / this.mostCommon : 0;
      }
      /**
       * Проверить стоимость слова
       * @param {string} word
       * @return стоимость слова, учитывается длинна слова и редкость, самое
       * редкое слово стоит в 2 раза дороже самого обыного с той же длинной
       */
      checkPrice(word) {
        let price = this.words[word];
        if (price > 0) return word.length + this.checkRarity(word) * this.longest;
        return -1;
      }
    }

    const OnlineConnection = new class {
      constructor() {
        this.isConnected = false;
        /** @type {VXsEvent<[boolean]>} */
        this.onIsOnlineChanged = new VXsEvent();
      }
    }

    class Profile {
      static instance = new Profile();
      static loadProfileOnline() {

      }
      static saveProfileOnline() {

      }
      static loadProfileOffline() {
        openFile(content => {
          let model = JSON.parse(content);
          this.instance = new Profile(model)
        }, this);
      }
      static saveProfileOffline() {
        saveFile(i.name, JSON.stringify(this.instance));
      }

      constructor(model) {
        if (arguments.length < 1) model = {};
        ({
          name: this.name
        } = model);
      }
    }
  </script>
  <style>
    .menuContainer {
      display: inline-block;
    }

    .menuButton {
      margin: 0.5em;
      width: 100%;
    }

    .newFinded {
      color: seagreen;
    }

    .finded {
      color: goldenrod;
    }

    .positive {
      color: seagreen;
    }

    .negative {
      color: crimson;
    }
  </style>
  <script type="text/babel">
    const {
      useState,
      useEffect,
      useRef
    } = /** @type {{useState:<T>(arg:T)=>[T, (arg:T)=>void],useEffect: (mount:()=>()=>void)=>void}} */ (window.React);

    /**
     * @typedef WordInfo информация о слове
     * @prop {string} word слово
     * @prop {number} rarity редкость
     * @prop {number} price стоимость
     * @prop {boolean} isFound найдено? (для результатов)
     */

    /**
     * Таблица слов разбитая по колонкам
     * @param {{wordsByLength:WordInfo[][]}} props
     */
    function WordsTable(props) {
      const { wordsByLength } = props;
      let res = [];
      let i = 0;
      let b;
      let header = [];
      for (let k = wordsByLength.length - 1; k > -1; k--)
        if (!wordsByLength[k] || 0 == wordsByLength[k].length) continue;
        else header.push((<th colspan={3}>{k}</th>));
      res.push((<tr>{header}</tr>))
      do {
        let row = [];
        b = false;
        for (let k = wordsByLength.length - 1; k > -1; k--) {
          if (!wordsByLength[k] || 0 == wordsByLength[k].length) continue;
          if (!wordsByLength[k] || !wordsByLength[k][i]) {
            row.push((<td colspan={3}></td>))
            continue;
          }
          b = true;
          let cell = wordsByLength[k][i].word
          if (wordsByLength[k][i].isFound) cell = (<b>{cell}</b>);
          row.push((<td>{cell}</td>),
            (<td>{wordsByLength[k][i].price}</td>),
            (<td>{wordsByLength[k][i].rarity}</td>));
        }
        if (b) res.push((<tr>{row}</tr>));
        i++;
      } while (b);
      return (
        <table>
          {res}
        </table>
      );
    }

    /**
     * Атрибуты основного меню 
     * @typedef MainMenuProps
     * @prop {undefined|()=>void} onNewGameClick - обаботчик кнопки новая игра
     * @prop {undefined|()=>void} onBackClick - обаботчик кнопки назад
     */

    /** 
     * Основное меню 
     * @param {MainMenuProps} props
     */
    function MainMenu(props) {
      let [menuState, setMenuState] = useState("main");

      function onNewGameClick() {
        if (!props || !props.onNewGameClick) return;
        props.onNewGameClick();
      }

      function onBackClick() {
        if (!props || !props.onBackClick) return;
        props.onBackClick();
      }

      function onBackToDefault() {
        setMenuState("mainMenu")
      }

      /** базовое состояние меню */
      function DefaultMenu() {
        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onNewGameClick}>Новая игра</button> <br />
            <button class="menuButton" onClick={() => setMenuState("dict")}>Посмотреть словарь</button> <br />
            <button class="menuButton" onClick={() => setMenuState("opts")}>Настройки</button> <br />
            <button class="menuButton" onClick={() => setMenuState("impexp")}>Импорт/Экспорт словаря</button><br />
            {
              props && props.onBackClick ?
                (<button class="menuButton" onClick={onBackClick}>Назад</button>) :
                (<br />)
            }
          </div>
        )
      }

      /** Просмотр словаря */
      function WordsDictionary() {
        /** @type {WordInfo[][]} */
        let wordsByLength = []
        for (let word in WordsManager.words) {
          if (!wordsByLength[word.length]) wordsByLength[word.length] = [];
          wordsByLength[word.length].push({
            word: word,
            price: Math.round(WordsManager.checkPrice(word) * 100) / 100,
            rarity: Math.round(WordsManager.checkRarity(word) * 100),
            isFound: false
          });
        }

        return (
          <div class="menuContainer">
            <WordsTable wordsByLength={wordsByLength} />
          </div>
        );
      }

      /** Настройки */
      function Options() {
        const { name } = Profile.instance;
        function onLoadContentOfflineClick() {
          Profile.loadProfileOffline();
        }
        function onSaveContentOfflineClick() {
          Profile.saveProfileOffline();
        }
        function SaveLoadOnline() {
          const [isConnected, setIsConnected] = useState(OnlineConnection.isConnected);
          useEffect(() => {
            OnlineConnection.onIsOnlineChanged.subscribe(setIsConnected);
            return () => OnlineConnection.onIsOnlineChanged.unsubscribe(setIsConnected);
          });
          if (!isConnected) return null;
          return (<div>
            Онлайн<br />
            <button class="menuButton" onClick={onSaveContentOfflineClick}>Сохранить профиль</button>
            <button class="menuButton" onClick={onLoadContentOfflineClick}>Загрузить профиль</button>
          </div>);
        }
        function SaveLoadOffline() {
          return (<div>
            Локально<br />
            <button class="menuButton" onClick={onSaveContentOfflineClick}>Сохранить профиль</button>
            <button class="menuButton" onClick={onLoadContentOfflineClick}>Загрузить профиль</button>
          </div>);
        }
        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onBackToDefault}>Назад</button><br />
            <SaveLoadOnline />
            <SaveLoadOffline />
          </div>

        );
      }

      function Importer() {
        const [text, setText] = useState("");

        function onSaveClick(event) {
          event.preventDefault();
          WordsManager.importText(text);
          onBackToDefault();
        }

        function onTextChange(event) {
          setText(event.target.value)
        }

        return (
          <form class="menuContainer" onSubmit={onSaveClick}>
            <input type="file" /><br />
            <textarea onChange={onTextChange}>{text}</textarea><br />
            <input class="menuButton" type="submit" value="Сохранить" />
          </form>
        );
      }

      switch (menuState) {
        case "main":
        default: return (<DefaultMenu />);
        case "opts":
          return (<Options />)
        case "dict":
          return (<WordsDictionary />)
        case "impexp":
          return (<Importer />)
      }
    }

    function Game(props) {
      const [state, setState] = useState("prepare");
      const [word, setWord] = useState("");
      /** 
       * @typedef resultsModel
       * @prop {number} score
       * @prop {string[]} findedWords
       * @prop {string} word
       */
      const [results, setResults] = useState(/** @type {resultsModel} */(null));

      function onBackClick() {
        if (!props || !props.onBackClick) return;
        props.onBackClick();
      }

      function selectWord(word) {
        setWord(word);
        setState("inGame");
      }

      /** 
       * @param {resultsModel} results 
       */
      function onGameOver(results) {
        setState("over");
        setResults(results);
      }

      function NewGame(props) {
        function getRandomWords() {
          return [
            WordsManager.getRndWord(),
            WordsManager.getRndWord(),
            WordsManager.getRndWord(),
            WordsManager.getRndWord()
          ];
        }

        const [rndWord, setRndWord] = useState(getRandomWords());
        const [searchWord, setSearchWord] = useState("");
        const [findedWords, setFindedWords] = useState(/** @type {string[]} */([]));

        function onRefreshRandom() {
          setRndWord(getRandomWords());
        }

        function onSearchWordChanged(event) {
          setSearchWord(event.target.value);
        }

        return (
          <div class="menuContainer">
            {props.children}
            <button class="menuButton" onClick={onBackClick}>в главное меню</button><br />
            Случайные слова <button onClick={onRefreshRandom}>🗘</button><br />
            <table>
              <tr>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[0])}>{rndWord[0]}</button></td>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[1])}>{rndWord[1]}</button></td>
              </tr>
              <tr>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[2])}>{rndWord[2]}</button></td>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[3])}>{rndWord[3]}</button></td>
              </tr>
            </table>
            <input type="text" value={searchWord} onChange={onSearchWordChanged} />
            <div>
              {findedWords.map((item) => (<button class="menuButton" onClick={() => selectWord(item)}>{item}</button>))}
            </div>
          </div>
        );
      }

      function InGame(props) {
        const [score, setScore] = useState(0);
        const [dScore, setDScore] = useState(0);
        /** 
         * @typedef letterModel 
         * @prop {string} char
         * @prop {boolean} isUsed
         */
        const [letters, setLetters] = useState(/** @type {letterModel[]} */(
          Array.from(word)
            .map(ch => {
              return {
                char: ch,
                isUsed: false
              }
            })
        ));
        /**
         * @typedef newLetterModel
         * @prop {string} char
         * @prop {number} fromLetter
         */
        const [newWord, setNewWord] = useState(/** @type {newLetterModel[]} */([]));
        const [findedWords, setFindedWords] = useState(/** @type {string[]} */([]));
        const [alreadyFinded, setAlreadyFinded] = useState("");
        const [lastFinded, setLastFinded] = useState("");

        /** @param {{
         *    char:string,
         *    enabled:boolean,
         *    position:number,
         *    onClick:(position:number)=>void
         * }} props */
        function Letter(props) {
          if (undefined === props.enabled) props.enabled = true;
          function onClick() {
            if (props.onClick) props.onClick(props.position);
          }
          return (
            <button onClick={onClick} disabled={!props.enabled}>{props.char}</button>
          )
        }

        /** 
         * @param {number} position 
         */
        function setLetterUsed(position, isUsed) {
          /** @type {letterModel[]} */
          let dLetters = [].concat(letters);
          dLetters[position].isUsed = isUsed;
          setLetters(dLetters);
        }
        /** 
         * @param {number} position 
         */
        function onLetterClick(position) {
          setLetterUsed(position, true);
          /** @type {newLetterModel[]} */
          let dNewWord = [].concat(newWord);
          let i = 0
          for (; i < dNewWord.length; i++)
            if (" " == dNewWord[i].char) break;
          dNewWord[i] = {
            char: letters[position].char,
            fromLetter: position
          }
          setNewWord(dNewWord);
        }

        /** 
         * @param {number} position 
         */
        function onNewLetterClick(position) {
          /** @type {newLetterModel[]} */
          let dNewWord = [].concat(newWord);
          setLetterUsed(dNewWord[position].fromLetter, false);
          dNewWord[position] = {
            char: " ",
            fromLetter: -1
          }
          setNewWord(dNewWord);
        }

        function changeScore(price) {
          setScore(score + price);
          setDScore(price);
        }

        /** Оценить слово */
        function onCheckWord() {
          let sWord = newWord.map(x => " " == x.char ? "" : x.char).join("");
          setLastFinded(sWord);
          setNewWord([]);
          /** @type {letterModel[]} */
          let dLetters = [].concat(letters);
          for (let i in dLetters) dLetters[i].isUsed = false;
          setLetters(dLetters);
          let letterPrice = WordsManager.checkPrice(sWord);
          if (-1 == letterPrice) return changeScore(letterPrice);
          let isAlreadyFinded = findedWords.find(x => x === sWord);
          if (isAlreadyFinded) setAlreadyFinded(isAlreadyFinded);
          else setFindedWords([sWord].concat(findedWords));
          changeScore(isAlreadyFinded ? 0 : letterPrice);
        }

        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onGameOver.bind(null, { score, findedWords, word })}>Завершить</button><br />
            <h2>{word}</h2>
            Очки: {Math.round(score * 100) / 100} {0 == score ? "" : (<span class={dScore > 0 ? "positive" : "negative"}>{dScore > 0 ? "+" : ""}{Math.round(dScore * 100) / 100}</span>)}<br />
            {newWord.map((l, i) => (<Letter char={l.char} position={i} enabled={" " != l.char} onClick={onNewLetterClick} />))}&nbsp;
            {0 != newWord ? (<button onClick={onCheckWord}>⟰</button>) : null}
            <br />
            {letters.map((l, i) => (<Letter char={l.char} enabled={!l.isUsed} position={i} onClick={onLetterClick} />))}
            <br />
            Найденные слова:
            <ul>
              {findedWords.map(word => (<li class={alreadyFinded == word ? "finded" :
                lastFinded == word ? "newFinded" :
                  ""}>{word}</li>))}
            </ul>
          </div>
        );
      }

      function GameOver() {
        /** @type {WordInfo[][]} */
        let wordsByLength = [];
        let wordKey = WordsManager.getWordKey(results.word);

        for (let word in WordsManager.words) {
          if (!WordsManager.checkTwoKeys(WordsManager.getWordKey(word), wordKey)) continue;
          if (!wordsByLength[word.length]) wordsByLength[word.length] = [];
          wordsByLength[word.length].push({
            word: word,
            price: Math.round(WordsManager.checkPrice(word) * 100) / 100,
            rarity: Math.round(WordsManager.checkRarity(word) * 100),
            isFound: results.findedWords.find(w => w == word) !== undefined
          });
        }
        return (
          <NewGame>
            <div>Результаты:</div>
            <div>Набрано очков: {results.score}</div>
            Найденные слова:<br />
            <WordsTable wordsByLength={wordsByLength} />
          </NewGame>
        );
      }

      switch (state) {
        case "prepare": return (<NewGame />);
        case "inGame": return (<InGame />);
        case "over": return (<GameOver />);
      }
    }

    function App() {
      const [gameState, setGameState] = useState("mainMenu");

      //const profile = CookieManager.get("profile") || {};

      function onNewGameClick() {
        setGameState("newGame");
      }
      function onBackClick() {
        setGameState("mainMenu");
      }

      return (<div>
        <h1>VX's Words</h1>
        {"mainMenu" == gameState ? (<MainMenu onNewGameClick={onNewGameClick} />) :
          (<Game onBackClick={onBackClick} />)}
      </div>)
    }
    ReactDOM.render(
      <App />,
      document.getElementById("app")
    );
  </script>
</head>

<body>
  <div id="app"></div>
</body>

</html>