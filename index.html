<!DOCTYPE html>
<html>

<head>
  <title>VX's Words</title>
  <script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/javascript">
    /**
     * @template TArgs extends any[]
     */
     class VXsEvent {
      constructor() {
        /** @type {((...args:TArgs)=>void)[]} */
        this.callbacks = [];
      }
      /** 
       * @param {(...args:TArgs)=>void} callback
       */
      subscribe(callback) {
        this.callbacks.push(callback)
      }
      /** 
       * @param {(...args:TArgs)=>void} callback
       */
      unsubscribe(callback) {
        let index = this.callbacks.findIndex(x=>x===callback);
        if (undefined == index) return;
        this.callbacks.splice(index, 1);
      }
      /**
       * @param {TArgs} args
       */
      invoke(...args) {
        let errors = [];
        for (let k in this.callbacks) if (this.callbacks[k].apply(null, args)) try { this.callbacks[k](value) } catch(e) { errors.push(e); }
        if (0 != errors.length) throw ["errors on invoke of event", errors];
      }
    }
  </script>
  <script type="text/javascript">
    /**
     * —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª 
     * @param {string} filename
     * @param {string} text
     */
    function saveFile(filename, text) {
      let oFile = document.createElement('a');
      oFile.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
      oFile.setAttribute('download', filename);
      if (document.createEvent) {
        let event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        oFile.dispatchEvent(event);
      }
      else {
        oFile.click();
      }
    }
    
    /**
     * –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª
     * @param {(this:Scope, content: string )=>void} callback
     * @param {Scope} scope
     * @template Scope
     */
    function openFile(callback, scope) {
      var iFile = document.createElement('input');
      iFile.type = 'file';
      iFile.onchange = e => { 
        var reader = new FileReader();
        reader.readAsText(e.target.files[0],'UTF-8');
        reader.onload = readerEvent => callback.call(scope || this, readerEvent.target.result);
      }
      if (document.createEvent) {
        let event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        iFile.dispatchEvent(event);
      }
      else {
        iFile.click();
      }
    }

    const CookieManager = new class {
      b64EncodeUnicode(str) {
        // first we use encodeURIComponent to get percent-encoded UTF-8,
        // then we convert the percent encodings into raw bytes which
        // can be fed into btoa.
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
          function toSolidBytes(match, p1) {
            return String.fromCharCode('0x' + p1);
          }));
      }
      b64DecodeUnicode(str) {
        // Going backwards: from bytestream, to percent-encoding, to original string.
        return decodeURIComponent(atob(str).split('').map(function (c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
      }
      /**
       * @param {string} key
       * @return {string}
       */
      getRaw(key) {
        return document.cookie.replace(`(?:(?:^|.*;\\s*)${key}\\s*\\=\\s*([^;]*).*$)|^.*$`, "$1");
      }
      /**
       * @param {string} key
       * @param {T?} def
       * @return {T}
       * @template T
       */
      get(key, def) {
        if (arguments.length < 2) def = null;
        let s = this.getRaw(key);
        s = this.b64DecodeUnicode(s);
        return s ? JSON.parse(s) : def;
      }
      /**
       * @param {string} key
       * @param {string} value
       */
      setRaw(key, value) {
        document.cookie = `${key}=${value}`;
      }
      /**
       * @param {string} key
       * @param {any} value
       */
      set(key, value) {
        value = null == value ? "" : JSON.stringify(value);
        value = this.b64EncodeUnicode(value);
        this.setRaw(key, value);
      }
    }
    const WordsManager = new class {
      constructor() {
        this.loadFromCookies();
      }
      loadFromCookies() {
        /** @type {{[key:string]:number}} */
        this.words = CookieManager.get("words", {});
      }
      saveToCookies() {
        CookieManager.set("words", this.words);
      }

      /** 
       * –†–∞–∑–±–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ —Å–ª–æ–≤–∞
       * @param {string} str 
       */
      splitOnSpecialChars(str) {
        let set = new Set([
          "~", "`",
          "!", "@", "#", "$", "%", "^", "&", "*", "(", ")",
          "_", "+", "-", "=",
          "[", "]", "{", "}", "\\", "|",
          ";", "'", ":", "\"",
          ",", ".", "<", ">", "/", "?",
          " ", "\t", "\r", "\n"
        ]);
        let arr = Array.from(str);
        let st = 0;
        let res = [];
        for (let i = 0; i < arr.length; i++) {
          if (!set.has(arr[i])) continue;
          if (st != i) res.push(str.substr(st, i - st).toUpperCase())
          st = i + 1;
        }
        if (st < arr.length) res.push(str.substr(st, arr.length - st).toUpperCase())
        return res;
      }
      /** 
       * –ò–º–ø–æ—Ä—Ç —Ç–µ–∫—Å—Ç–∞
       * @param {string} raw 
       */
      importText(raw) {
        this.words = {};
        let arr = this.splitOnSpecialChars(raw);
        for (let i = 0; i < arr.length; i++) {
          if (!this.words[arr[i]]) this.words[arr[i]] = 1;
          else this.words[arr[i]]++;
        }
        this.saveToCookies();
      }
      /** 
       * @param {number?} length
       * @return {string} 
       */
      getRndWord(length) {
        if (undefined == length) length = 0;
        let findedWords = Object.entries(this.words)
          .filter(x => x[0].length > length)
          .map(x => x[0]);
        return findedWords[Math.floor(Math.random() * findedWords.length)]
      }
    }

    

    const OnlineConnection = new class {
      constructor() {
        this.isConnected = false;
        /** @type {VXsEvent<[boolean]>} */
        this.onIsOnlineChanged = new VXsEvent();
      }
    }

    class Profile {
      static instance = new Profile();
      static loadProfileOnline() {

      }
      static saveProfileOnline() {
        
      }
      static loadProfileOffline() {
        openFile(content => {
          let model = JSON.parse(content);
          this.instance = new Profile(model)
        }, this);
      }
      static saveProfileOffline() {
        saveFile(i.name, JSON.stringify(this.instance));
      }

      constructor(model) {
        if (arguments.length < 1) model = {};
        ({ 
          name: this.name 
        } = model);
      }
    }
  </script>
  <style>
    .menuContainer {
      display: inline-block;
    }

    .menuButton {
      margin: 0.5em;
      width: 100%;
    }
  </style>
  <script type="text/babel">
    const {
      useState,
      useEffect,
      useRef
    } = /** @type {{useState:<T>(arg:T)=>[T, (arg:T)=>void],useEffect: (mount:()=>()=>void)=>void}} */ (window.React);

    /**
     * –ê—Ç—Ä–∏–±—É—Ç—ã –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é 
     * @typedef MainMenuProps
     * @prop {undefined|()=>void} onNewGameClick - –æ–±–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –Ω–æ–≤–∞—è –∏–≥—Ä–∞
     * @prop {undefined|()=>void} onBackClick - –æ–±–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –Ω–∞–∑–∞–¥
     */

    /** 
     * –û—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é 
     * @param {MainMenuProps} props
     */
    function MainMenu(props) {
      let [menuState, setMenuState] = useState("main");

      function onNewGameClick() {
        if (!props || !props.onNewGameClick) return;
        props.onNewGameClick();
      }

      function onBackClick() {
        if (!props || !props.onBackClick) return;
        props.onBackClick();
      }

      function onBackToDefault() {
        setMenuState("mainMenu")
      }

      /** –±–∞–∑–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ–Ω—é */
      function DefaultMenu() {
        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onNewGameClick}>–ù–æ–≤–∞—è –∏–≥—Ä–∞</button> <br />
            <button class="menuButton" onClick={() => setMenuState("dict")}>–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ª–æ–≤–∞—Ä—å</button> <br />
            <button class="menuButton" onClick={() => setMenuState("opts")}>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button> <br />
            <button class="menuButton" onClick={() => setMenuState("impexp")}>–ò–º–ø–æ—Ä—Ç/–≠–∫—Å–ø–æ—Ä—Ç —Å–ª–æ–≤–∞—Ä—è</button><br />
            {
              props && props.onBackClick ?
                (<button class="menuButton" onClick={onBackClick}>–ù–∞–∑–∞–¥</button>) :
                (<br />)
            }
          </div>
        )
      }

      /** –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ª–æ–≤–∞—Ä—è */
      function WordsDictionary() {
        var words = {
          "aaa": "aaa"
        };
        return (
          <div class="menuContainer">
            <ul>
              {Object.entries(WordsManager.words)
                .map(w => (<li>{w[0]}: {w[1]}</li>))}
            </ul>
            <button class="menuButton" onClick={onBackToDefault}>–ó–∞–∫—Ä—ã—Ç—å</button>
          </div>
        );
      }

      /** –ù–∞—Å—Ç—Ä–æ–π–∫–∏ */
      function Options() {
        const {name} = Profile.instance;
        function onLoadContentOfflineClick() {
          Profile.loadProfileOffline();
        }
        function onSaveContentOfflineClick() {
          Profile.saveProfileOffline();
        }
        function SaveLoadOnline() {
          const [isConnected, setIsConnected] = useState(OnlineConnection.isConnected);
          useEffect(()=> {
            OnlineConnection.onIsOnlineChanged.subscribe(setIsConnected);
            return () => OnlineConnection.onIsOnlineChanged.unsubscribe(setIsConnected);
          });
          if (!isConnected) return null;
          return (<div>
            –û–Ω–ª–∞–π–Ω<br/>
            <button class="menuButton" onClick={onSaveContentOfflineClick}>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</button>
            <button class="menuButton" onClick={onLoadContentOfflineClick}>–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</button>
          </div>);
        }
        function SaveLoadOffline() {
          return (<div>
            –õ–æ–∫–∞–ª—å–Ω–æ<br/>
            <button class="menuButton" onClick={onSaveContentOfflineClick}>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</button>
            <button class="menuButton" onClick={onLoadContentOfflineClick}>–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</button>
          </div>);
        }
        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onBackToDefault}>–ù–∞–∑–∞–¥</button><br/>
            <SaveLoadOnline />
            <SaveLoadOffline />
          </div>

        );
      }

      function Importer() {
        const [text, setText] = useState("");

        function onSaveClick(event) {
          event.preventDefault();
          WordsManager.importText(text);
          onBackToDefault();
        }

        function onTextChange(event) {
          setText(event.target.value)
        }

        return (
          <form class="menuContainer" onSubmit={onSaveClick}>
            <input type="file" /><br />
            <textarea onChange={onTextChange}>{text}</textarea><br />
            <input class="menuButton" type="submit" value="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å" />
          </form>
        );
      }

      switch (menuState) {
        case "main":
        default: return (<DefaultMenu />);
        case "opts":
          return (<Options />)
        case "dict":
          return (<WordsDictionary />)
        case "impexp":
          return (<Importer />)
      }
    }

    function Game(props) {
      const [state, setState] = useState("prepare");
      const [word, setWord] = useState("");

      function onBackClick() {
        if (!props || !props.onBackClick) return;
        props.onBackClick();
      }

      function selectWord(word) {
        setWord(word);
        setState("inGame");
      }

      function onGameOver() {
        setState("over")
      }

      function NewGame(props) {
        function getRandomWords() {
          return [
            WordsManager.getRndWord(),
            WordsManager.getRndWord(),
            WordsManager.getRndWord(),
            WordsManager.getRndWord()
          ];
        }

        const [rndWord, setRndWord] = useState(getRandomWords());
        const [searchWord, setSearchWord] = useState("");
        const [findedWords, setFindedWords] = useState([]);

        function onRefreshRandom() {
          setRndWord(getRandomWords());
        }

        function onSearchWordChanged(event) {
          setSearchWord(event.target.value);
        }

        return (
          <div class="menuContainer">
            {props.children}
            <button class="menuButton" onClick={onBackClick}>–≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button><br />
            –°–ª—É—á–∞–π–Ω—ã–µ —Å–ª–æ–≤–∞ <button onClick={onRefreshRandom}>üóò</button><br />
            <table>
              <tr>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[0])}>{rndWord[0]}</button></td>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[1])}>{rndWord[1]}</button></td>
              </tr>
              <tr>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[2])}>{rndWord[2]}</button></td>
                <td><button class="menuButton" onClick={() => selectWord(rndWord[3])}>{rndWord[3]}</button></td>
              </tr>
            </table>
            <input type="text" value={searchWord} onChange={onSearchWordChanged} />
            <div>
              {findedWords.map((item) => (<button class="menuButton" onClick={() => selectWord(item)}>{item}</button>))}
            </div>
          </div>
        );
      }

      function InGame() {
        const [newWord, setNewWord] = useState("");
        return (
          <div class="menuContainer">
            <button class="menuButton" onClick={onGameOver}>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button><br />
            <h2>{word}</h2>
            {Array.from(newWord).map((ch, i) => (<button onClick={onGameOver} enabled={true}>{ch}</button>))}
            {Array.from(word).map((ch, i) => (<button onClick={onGameOver} enabled={true}>{ch}</button>))}
          </div>
        );
      }

      function GameOver() {
        return (
          <NewGame>
            <div>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:</div>
          </NewGame>
        );
      }

      switch (state) {
        case "prepare": return (<NewGame />);
        case "inGame": return (<InGame />);
        case "over": return (<GameOver />);
      }
    }

    function App() {
      const [gameState, setGameState] = useState("mainMenu");

      const profile = CookieManager.get("profile") || {};

      function onNewGameClick() {
        setGameState("newGame");
      }
      function onBackClick() {
        setGameState("mainMenu");
      }

      return (<div>
        <h1>VX's Words</h1>
        {"mainMenu" == gameState ? (<MainMenu onNewGameClick={onNewGameClick} />) :
          (<Game onBackClick={onBackClick} />)}
      </div>)
    }
    ReactDOM.render(
      <App />,
      document.getElementById("app")
    );
  </script>
</head>

<body>
  <div id="app"></div>
</body>

</html>